import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { Popover } from '@wordpress/components';
import { getScrollContainer } from '@wordpress/dom';
import { useMemo } from '@wordpress/element';
/**
 * Internal dependencies
 */

import { __unstableUseBlockElement as useBlockElement } from '../block-list/use-block-props/use-block-refs';
import usePopoverScroll from './use-popover-scroll';
export default function BlockPopover(_ref) {
  let {
    clientId,
    bottomClientId,
    children,
    __unstableRefreshSize,
    __unstableCoverTarget = false,
    __unstablePopoverSlot,
    __unstableContentRef,
    ...props
  } = _ref;
  const selectedElement = useBlockElement(clientId);
  const lastSelectedElement = useBlockElement(bottomClientId !== null && bottomClientId !== void 0 ? bottomClientId : clientId);
  const popoverScrollRef = usePopoverScroll(__unstableContentRef);
  const style = useMemo(() => {
    if (!selectedElement || lastSelectedElement !== selectedElement) {
      return {};
    }

    return {
      position: 'absolute',
      width: selectedElement.offsetWidth,
      height: selectedElement.offsetHeight
    };
  }, [selectedElement, lastSelectedElement, __unstableRefreshSize]);

  if (!selectedElement || bottomClientId && !lastSelectedElement) {
    return null;
  }

  const anchorRef = {
    top: selectedElement,
    bottom: lastSelectedElement
  };
  const {
    ownerDocument
  } = selectedElement;
  const stickyBoundaryElement = ownerDocument.defaultView.frameElement || getScrollContainer(selectedElement) || ownerDocument.body;
  return createElement(Popover, _extends({
    ref: popoverScrollRef,
    noArrow: true,
    animate: false,
    position: "top right left",
    focusOnMount: false,
    anchorRef: anchorRef,
    __unstableStickyBoundaryElement: __unstableCoverTarget ? undefined : stickyBoundaryElement // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot || null,
    __unstableBoundaryParent: true // Observe movement for block animations (especially horizontal).
    ,
    __unstableObserveElement: selectedElement // Used to safeguard sticky position behavior against cases where it would permanently
    // obscure specific sections of a block.
    ,
    __unstableEditorCanvasWrapper: __unstableContentRef === null || __unstableContentRef === void 0 ? void 0 : __unstableContentRef.current,
    __unstableForcePosition: __unstableCoverTarget
  }, props, {
    className: classnames('block-editor-block-popover', props.className)
  }), __unstableCoverTarget && createElement("div", {
    style: style
  }, children), !__unstableCoverTarget && children);
}
//# sourceMappingURL=index.js.map